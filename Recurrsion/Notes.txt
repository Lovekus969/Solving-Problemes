                                                                                      Recursion & Backtracking

Concepts to cover:
              Recursion tree & base cases =>> Backtracking pattern (choose → explore → unchoose)
    Why important: 
              Forms the mental base for DP, tree traversal, N-Queens, and permutations.
Key problems:
                        N-Queens
                        Subset generation
                        Rat in a maze / Path finding

What is Recursion? 
Recursion is a programming technique in which a function solves a problem by breaking it down into smaller subproblems of the same type and calling itself with updated parameters until it reaches a well-defined base case.

What is Base Case?
    A base case is the simplest possible instance of a problem that can be solved directly without further recursion. It prevents infinite recursion by acting as the             termination condition for recursive calls.
Example: In factorial, n == 0 || n == 1 is the base case.

What is a Recursive Case?
      A recursive case is the part of a recursive algorithm where the problem is reduced into one or more smaller subproblems of the same type, and the function calls itself       to solve those subproblems.
Example: In factorial, n * factorial(n - 1) is the recursive case.

What is Call Stack Behavior?
      The call stack is a runtime data structure that keeps track of active function calls. In recursion, each call creates a new stack frame storing parameters, local          variables, and the return address.
This consumes O(depth) space, where depth is the maximum recursion depth.

What is Time Complexity Awareness?
    Time complexity in recursion depends on how many recursive calls are made and the work done per call. Naive recursion can lead to exponential complexity when      overlapping subproblems are recomputed (e.g., Fibonacci). O(2^n)
Optimizing with memoization (caching results) or bottom-up dynamic programming reduces complexity to polynomial or better.
